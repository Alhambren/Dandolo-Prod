/**
 * Superior streaming implementation for real-time AI interactions
 * 
 * Supports multiple streaming protocols:
 * - Server-Sent Events (SSE) for HTTP streaming
 * - WebSocket for real-time bidirectional communication
 * - Polling fallback for constrained environments
 */

import { EventEmitter } from 'eventemitter3';
import WebSocket from 'ws';
import {
  StreamingChunk,
  StreamingOptions,
  ChatCompletionRequest,
  ChatCompletionResponse,
  DandoloError,
  AgentEvent
} from './types';
import { DandoloClient } from './client';
import { createDandoloError } from './errors';

export type StreamingProtocol = 'sse' | 'websocket' | 'polling';

export interface StreamingConfig {
  protocol?: StreamingProtocol;
  reconnect?: boolean;
  maxReconnectAttempts?: number;
  reconnectDelay?: number;
  heartbeatInterval?: number;
  bufferSize?: number;
}

/**
 * Enhanced streaming client with multiple protocol support
 */
export class DandoloStreamClient extends EventEmitter {
  private activeStreams: Map<string, StreamSession> = new Map();
  private wsConnection?: WebSocket;
  private config: Required<StreamingConfig>;
  
  constructor(private client: DandoloClient) {
    super();
    
    this.config = {
      protocol: 'sse',
      reconnect: true,
      maxReconnectAttempts: 3,
      reconnectDelay: 1000,
      heartbeatInterval: 30000,
      bufferSize: 1024 * 1024 // 1MB
    };
  }
  
  /**\n   * Configure streaming behavior\n   */\n  configure(config: Partial<StreamingConfig>): void {\n    Object.assign(this.config, config);\n    this.emit('config_updated', this.config);\n  }\n  \n  /**\n   * Create a streaming chat completion\n   */\n  async stream(\n    request: ChatCompletionRequest,\n    options: StreamingOptions = {}\n  ): Promise<void> {\n    const streamId = `stream_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    try {\n      const session = new StreamSession({\n        id: streamId,\n        client: this.client,\n        request,\n        options,\n        protocol: this.config.protocol,\n        config: this.config\n      });\n      \n      this.activeStreams.set(streamId, session);\n      \n      // Set up session event handlers\n      session.on('chunk', (chunk: StreamingChunk) => {\n        options.onChunk?.(chunk);\n        this.emit('chunk', { streamId, chunk });\n      });\n      \n      session.on('complete', (response: ChatCompletionResponse) => {\n        options.onComplete?.(response);\n        this.emit('complete', { streamId, response });\n        this.activeStreams.delete(streamId);\n      });\n      \n      session.on('error', (error: DandoloError) => {\n        options.onError?.(error);\n        this.emit('error', { streamId, error });\n        this.activeStreams.delete(streamId);\n      });\n      \n      // Start the stream\n      await session.start();\n      \n    } catch (error) {\n      const dandoloError = createDandoloError(error);\n      options.onError?.(dandoloError);\n      this.emit('error', { streamId, error: dandoloError });\n      throw dandoloError;\n    }\n  }\n  \n  /**\n   * Create a real-time WebSocket connection for bidirectional communication\n   */\n  async createRealtimeConnection(): Promise<RealtimeConnection> {\n    if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) {\n      return new RealtimeConnection(this.wsConnection, this);\n    }\n    \n    const wsUrl = this.client.configuration.baseURL\n      .replace('http://', 'ws://')\n      .replace('https://', 'wss://') + '/v1/realtime';\n    \n    const ws = new WebSocket(wsUrl, {\n      headers: {\n        'Authorization': `Bearer ${this.client.configuration.apiKey}`,\n        'X-Agent-ID': this.client.configuration.agentId || ''\n      }\n    });\n    \n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('WebSocket connection timeout'));\n      }, 10000);\n      \n      ws.on('open', () => {\n        clearTimeout(timeout);\n        this.wsConnection = ws;\n        this.setupWebSocketHandlers(ws);\n        resolve(new RealtimeConnection(ws, this));\n      });\n      \n      ws.on('error', (error) => {\n        clearTimeout(timeout);\n        reject(createDandoloError(error));\n      });\n    });\n  }\n  \n  /**\n   * Stop a specific stream\n   */\n  stopStream(streamId: string): void {\n    const session = this.activeStreams.get(streamId);\n    if (session) {\n      session.stop();\n      this.activeStreams.delete(streamId);\n    }\n  }\n  \n  /**\n   * Stop all active streams\n   */\n  stopAllStreams(): void {\n    for (const [streamId, session] of this.activeStreams) {\n      session.stop();\n    }\n    this.activeStreams.clear();\n  }\n  \n  /**\n   * Get information about active streams\n   */\n  getActiveStreams(): string[] {\n    return Array.from(this.activeStreams.keys());\n  }\n  \n  /**\n   * Setup WebSocket event handlers\n   */\n  private setupWebSocketHandlers(ws: WebSocket): void {\n    ws.on('message', (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n        this.emit('realtime_message', message);\n      } catch (error) {\n        this.emit('error', createDandoloError(error));\n      }\n    });\n    \n    ws.on('close', () => {\n      this.emit('realtime_disconnected');\n      \n      // Auto-reconnect if configured\n      if (this.config.reconnect) {\n        setTimeout(() => {\n          this.createRealtimeConnection().catch(error => {\n            this.emit('error', error);\n          });\n        }, this.config.reconnectDelay);\n      }\n    });\n    \n    ws.on('error', (error) => {\n      this.emit('error', createDandoloError(error));\n    });\n  }\n}\n\n/**\n * Individual streaming session\n */\nclass StreamSession extends EventEmitter {\n  private abortController?: AbortController;\n  private reconnectAttempts = 0;\n  \n  constructor(private params: {\n    id: string;\n    client: DandoloClient;\n    request: ChatCompletionRequest;\n    options: StreamingOptions;\n    protocol: StreamingProtocol;\n    config: Required<StreamingConfig>;\n  }) {\n    super();\n  }\n  \n  async start(): Promise<void> {\n    switch (this.params.protocol) {\n      case 'sse':\n        return this.startSSEStream();\n      case 'websocket':\n        return this.startWebSocketStream();\n      case 'polling':\n        return this.startPollingStream();\n      default:\n        throw new Error(`Unsupported streaming protocol: ${this.params.protocol}`);\n    }\n  }\n  \n  stop(): void {\n    this.abortController?.abort();\n    this.emit('stopped');\n  }\n  \n  private async startSSEStream(): Promise<void> {\n    this.abortController = new AbortController();\n    \n    try {\n      const response = await fetch(`${this.params.client.configuration.baseURL}/v1/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.params.client.configuration.apiKey}`,\n          'Content-Type': 'application/json',\n          'Accept': 'text/event-stream',\n          'Cache-Control': 'no-cache',\n          ...(this.params.client.configuration.agentId && {\n            'X-Agent-ID': this.params.client.configuration.agentId\n          })\n        },\n        body: JSON.stringify({\n          ...this.params.request,\n          stream: true\n        }),\n        signal: this.abortController.signal\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw createDandoloError({ response: { status: response.status, data: errorData } });\n      }\n      \n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('Response body is not readable');\n      }\n      \n      const decoder = new TextDecoder();\n      let buffer = '';\n      let fullResponse = '';\n      let totalTokens = 0;\n      \n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          \n          if (done) break;\n          \n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n          \n          for (const line of lines) {\n            const trimmedLine = line.trim();\n            \n            if (trimmedLine === '' || trimmedLine === 'data: [DONE]') {\n              continue;\n            }\n            \n            if (trimmedLine.startsWith('data: ')) {\n              try {\n                const jsonStr = trimmedLine.slice(6);\n                const data = JSON.parse(jsonStr);\n                \n                // Handle content delta\n                if (data.choices && data.choices[0] && data.choices[0].delta) {\n                  const delta = data.choices[0].delta;\n                  if (delta.content) {\n                    fullResponse += delta.content;\n                    \n                    const chunk: StreamingChunk = {\n                      content: delta.content,\n                      done: false,\n                      model: data.model,\n                      agent_metadata: data.agent_metadata,\n                      workflow_state: data.workflow_state,\n                      instruction_feedback: data.instruction_feedback\n                    };\n                    \n                    this.emit('chunk', chunk);\n                  }\n                }\n                \n                // Handle completion\n                if (data.choices && data.choices[0] && data.choices[0].finish_reason) {\n                  totalTokens = data.usage?.total_tokens || 0;\n                  \n                  const finalChunk: StreamingChunk = {\n                    content: '',\n                    done: true,\n                    model: data.model,\n                    tokens: totalTokens,\n                    agent_metadata: data.agent_metadata,\n                    workflow_state: data.workflow_state,\n                    instruction_feedback: data.instruction_feedback\n                  };\n                  \n                  this.emit('chunk', finalChunk);\n                  \n                  const response: ChatCompletionResponse = {\n                    id: data.id || `chatcmpl-${Date.now()}`,\n                    object: 'chat.completion',\n                    created: Math.floor(Date.now() / 1000),\n                    model: data.model,\n                    choices: [{\n                      index: 0,\n                      message: {\n                        role: 'assistant',\n                        content: fullResponse\n                      },\n                      finish_reason: data.choices[0].finish_reason\n                    }],\n                    usage: {\n                      prompt_tokens: Math.floor(totalTokens * 0.7),\n                      completion_tokens: Math.floor(totalTokens * 0.3),\n                      total_tokens: totalTokens\n                    },\n                    dandolo_agent: data.dandolo_agent\n                  };\n                  \n                  this.emit('complete', response);\n                  return;\n                }\n              } catch (parseError) {\n                // Skip malformed JSON lines\n                console.warn('Skipping malformed SSE data:', parseError);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n      \n    } catch (error: any) {\n      if (error.name === 'AbortError') {\n        return; // Stream was intentionally stopped\n      }\n      \n      // Auto-retry on connection errors\n      if (this.shouldRetry(error)) {\n        await this.retry();\n        return;\n      }\n      \n      throw createDandoloError(error);\n    }\n  }\n  \n  private async startWebSocketStream(): Promise<void> {\n    // WebSocket streaming implementation\n    throw new Error('WebSocket streaming not yet implemented');\n  }\n  \n  private async startPollingStream(): Promise<void> {\n    // Polling-based streaming implementation\n    throw new Error('Polling streaming not yet implemented');\n  }\n  \n  private shouldRetry(error: any): boolean {\n    return (\n      this.reconnectAttempts < this.params.config.maxReconnectAttempts &&\n      this.params.config.reconnect &&\n      (error.code === 'ECONNRESET' || error.code === 'ENOTFOUND' || error.status >= 500)\n    );\n  }\n  \n  private async retry(): Promise<void> {\n    this.reconnectAttempts++;\n    const delay = this.params.config.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    \n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    try {\n      await this.start();\n    } catch (error) {\n      if (this.shouldRetry(error)) {\n        return this.retry();\n      }\n      throw error;\n    }\n  }\n}\n\n/**\n * Real-time bidirectional WebSocket connection\n */\nexport class RealtimeConnection extends EventEmitter {\n  constructor(\n    private ws: WebSocket,\n    private streamClient: DandoloStreamClient\n  ) {\n    super();\n    this.setupEventHandlers();\n  }\n  \n  /**\n   * Send a message through the WebSocket connection\n   */\n  send(message: any): void {\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      throw new Error('WebSocket connection is not open');\n    }\n  }\n  \n  /**\n   * Send a chat message and receive streaming response\n   */\n  async chat(message: string): Promise<void> {\n    this.send({\n      type: 'chat',\n      data: {\n        message,\n        timestamp: Date.now()\n      }\n    });\n  }\n  \n  /**\n   * Subscribe to agent events\n   */\n  subscribe(eventType: string): void {\n    this.send({\n      type: 'subscribe',\n      data: { eventType }\n    });\n  }\n  \n  /**\n   * Close the connection\n   */\n  close(): void {\n    this.ws.close();\n  }\n  \n  /**\n   * Get connection status\n   */\n  get isConnected(): boolean {\n    return this.ws.readyState === WebSocket.OPEN;\n  }\n  \n  private setupEventHandlers(): void {\n    this.ws.on('message', (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n        this.emit('message', message);\n        \n        // Handle different message types\n        switch (message.type) {\n          case 'chat_chunk':\n            this.emit('chunk', message.data);\n            break;\n          case 'agent_event':\n            this.emit('agent_event', message.data);\n            break;\n          case 'error':\n            this.emit('error', createDandoloError(message.data));\n            break;\n        }\n      } catch (error) {\n        this.emit('error', createDandoloError(error));\n      }\n    });\n    \n    this.ws.on('close', () => {\n      this.emit('disconnected');\n    });\n    \n    this.ws.on('error', (error) => {\n      this.emit('error', createDandoloError(error));\n    });\n  }\n}\n\nexport default DandoloStreamClient;"}